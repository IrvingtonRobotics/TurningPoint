#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    liftLeftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    liftRightPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           flywheelLeft,  tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           clawFlip,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           conveyor,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          flywheelRight, tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

// main controller
#define leftDriveJoystick vexRT[Ch3]
#define rightDriveJoystick vexRT[Ch2]
#define clawButton vexRT[Btn7U]
// partner (add Xmtr2 to end of name for partner joystick)
#define armJoystick vexRT[Ch2Xmtr2]
#define conveyorUpButton vexRT[Btn6UXmtr2]
#define conveyorDownButton vexRT[Btn6DXmtr2]
#define flywheelButton vexRT[Btn8UXmtr2]

#include "utils.c"
#include "atomic.c"
#include "tasks.c"
#include "helpers.c"
#include "controllers.c"

// ---- MAIN CONTROL

void pre_auton() {
	// stop tasks while changing from autonomous to usercontrol
	bStopTasksBetweenModes = true;
}

task autonomous() {
	startAllTasks();
	// 85 is p much max speed since speed is nonlinear, 60 is reasonable speed
	bool isRed = false;
	// practice as if blue, then negative of drive angles for red
	angleMultiplier = isRed ? -1 : 1;
	// false --> starting position closer to flags
	// true --> starting position closer to posts
	bool startNearFlags = true;
	// completely different routines by sides
	if (startNearFlags) {
		// start at edge of starting tile closer to the flag
		// drive forward then turn to shoot toward high flag
		driveStraight(80, 12);
		rotateAngle(90);
		shoot(3, 30);
		// pick up cap
		rotateAngle(-45);
		driveStraight(80, 20);
		// TODO: lift to pick up the cap
		// drive to pole
		driveStraight(-80, -20);
		rotateAngle(-135);
		driveStraight(80, 24);
		rotateAngle(-90);
		driveStraight(80, 24);
		// TODO: lift the lift
		flipClaw();
		} else {

	}
	angleMultiplier = 1;
}

task usercontrol() {
	startAllTasks();
	while (true) {
		if (vexRT[Btn8D]) {
			driveStraight(80, 24);
		}
		if (vexRT[Btn8R]) {
			rotateAngle(360);
		}
		if (vexRT[Btn8L]) {
			flipClaw();
		}
		doClaw();
		doDrive();
		doArms();
		doConveyor();
		doFlywheel();
	}
}
