#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    liftLeftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    liftRightPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           flywheelLeft,  tmotorVex393TurboSpeed_HBridge, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port2,           clawFlip,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           conveyor,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          flywheelRight, tmotorVex393TurboSpeed_HBridge, PIDControl, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

// main controller
#define leftDriveJoystick vexRT[Ch3]
#define rightDriveJoystick vexRT[Ch2]
#define clawButton vexRT[Btn7U]
// partner (add Xmtr2 to end of name for partner joystick)
#define armJoystick vexRT[Ch2Xmtr2]
#define conveyorUpButton vexRT[Btn6UXmtr2]
#define conveyorDownButton vexRT[Btn6DXmtr2]
#define flywheelButton vexRT[Btn8UXmtr2]

// configs
// make sure A is less than about 1200
#define clawPosA 750
#define clawPosB (clawPosA + 2782)

// for driving straight
int driveClicksLeft = 0;
int leftDriveSpeed = 0;
int rightDriveSpeed = 0;

// ---- HELPERS

int min(int a, int b) {
	return a < b ? a : b;
}
int max(int a, int b) {
	return a > b ? a : b;
}

int bound(int in, int min, int max) {
	if (min > max) {
		int temp = min;
		min = max;
		max = temp;
	}
	if (in < min) {
		return min;
		} else if (in > max) {
		return max;
		} else {
		return in;
	}
}

int bound(int in, int absMax) {
	return bound(in, absMax, -absMax);
}

int deDead(int in, int threshold) {
	// deal with dead zone
	if (abs(in) < threshold) {
		return 0;
	}
	return in;
}

int deDead(int in) {
	return deDead(in, 15);
}

// ---- MOVE: wrappers around atomic movement functions

void drive(int leftPow, int rightPow) {
	/* Positive: move forward;
	* Negative: move backward
	**/
	// Move the left side of the robot
	motor[driveLeftFront] = leftPow;
	motor[driveLeftBack] = leftPow;
	// Move the right side of the robot
	motor[driveRightFront] = rightPow;
	motor[driveRightBack] = rightPow;
}

void moveDrive(int left, int right) {
	leftDriveSpeed = left;
	rightDriveSpeed = right;
}

void driveStraight(int speed, int distance) {
	// where's copysign?
	speed = sgn(distance) * abs(speed);
	moveDrive(speed, speed);
	driveClicksLeft = abs(distance) * 360;
}

void moveArms(int dir) {
	// move both arms in unison
	motor[liftTop] = dir;
	motor[liftBottom] = dir;
}

void moveConveyor(int speed) {
	// move conveyor
	motor[conveyor] = speed;
}

void moveFlywheel(int speed) {
	motor[flywheelLeft] = speed;
	motor[flywheelRight] = speed;
}

void moveClaw(int speed) {
	motor[clawFlip] = speed;
}

int clawPosition() {
	return SensorValue[clawPot];
}

int liftBottomPosition() {
	return min(SensorValue[liftLeftPot], SensorValue[liftRightPot]);
}

int leftTopPosition() {
	return max(SensorValue[liftLeftPot], SensorValue[liftRightPot]);
}

int liftPosition() {
	return (SensorValue[liftLeftPot] + SensorValue[liftRightPot]) / 2;
}

// ---- MOVE: advanced movement (autom helpers)

// drive

void rotateInPlace(int speed) {
	/* positive speed: turn right
	* negative speed: turn left
	*/
	moveDrive(speed, -speed);
}

void stopDriving() {
	moveDrive(0, 0);
}

void waitMS(int millis) {
	wait1Msec(millis);
}

void wait(int seconds) {
	wait1Msec(seconds * 1000);
}

int angleMultiplier = 1;
void rotateAngle(int angle) {
	// calibrate so angle is in degrees
	// positive --> clockwise
	// TOCALIBRATE
	rotateInPlace(sgn(angle)* 60);
	waitMS(abs(angle) * 10);
	stopDriving();
}

void shoot(int flag, int distanceFromBase) {
	// 3 for top flag, 2 for middle flag
	int dx = distanceFromBase;
	int dy;
	if (flag == 3) {
		dy = 46;
		} else if (flag == 2) {
		dy = 32;
	}
	// TODO: now do some physics and speed curve to determine motor control
}

int clawTarget = clawPosA;

void flipClaw() {
	int pos = clawPosition();
	if (abs(pos - clawPosA) < abs(pos - clawPosB)) {
		clawTarget = clawPosB;
		} else {
		clawTarget = clawPosA;
	}
}

// ---- DO: observe input and act upon it

// drive

void doDrive() {
	// two joysticks
	int leftSpeed = deDead(leftDriveJoystick);
	int rightSpeed = deDead(rightDriveJoystick);
	moveDrive(leftSpeed, rightSpeed);
}

// conveyor

void doConveyor() {
	if (conveyorUpButton) {
		moveConveyor(127);
		} else if (conveyorDownButton) {
		moveConveyor(-127);
		} else {
		moveConveyor(0);
	}
}

// flywheel

void doFlywheel() {
	if (flywheelButton) {
		moveFlywheel(127);
		} else {
		moveFlywheel(0);
	}
}

// arm

void doArms() {
	int speed = deDead(armJoystick);
	moveArms(speed);
}

// claw

bool lastClawButtonValue = false;
bool clawFlipped = true;
int clawDir = 0;

void doClaw() {
	// for flipping 180
	bool currentClawButtonValue = clawButton ? true : false;
	if (currentClawButtonValue && !lastClawButtonValue) {
		flipClaw();
	}
	lastClawButtonValue = currentClawButtonValue;
}

// ---- MAIN CONTROL

task clawController() {
	while(true) {
		int error = clawTarget - clawPosition();
		// adjust multiplier as kP (proportionality coefficient)
		int motorPower = error / 7;
		motorPower = bound(motorPower, 127);
		motorPower = deDead(motorPower);
		moveClaw(motorPower);
		wait1Msec(10);
	}
}

task driveController() {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while(true) {
		if (driveClicksLeft > 0) {
			int left = -SensorValue[leftEncoder];
			int right = -SensorValue[rightEncoder];
			int error = right - left;
			rightDriveSpeed += error / 10;
			driveClicksLeft -= abs(right);
			SensorValue[leftEncoder] = 0;
			SensorValue[rightEncoder] = 0;
		}
		drive(leftDriveSpeed, rightDriveSpeed);
		wait1Msec(20);
	}
}

void startAllTasks() {
	startTask(clawController);
	startTask(driveController);
}

void pre_auton() {
	// stop tasks while changing from autonomous to usercontrol
	bStopTasksBetweenModes = true;
}

task autonomous() {
	startAllTasks();
	// 85 is p much max speed since speed is nonlinear, 60 is reasonable speed
	bool isRed = false;
	// practice as if blue, then negative of drive angles for red
	angleMultiplier = isRed ? -1 : 1;
	// false --> starting position closer to flags
	// true --> starting position closer to posts
	bool startNearFlags = true;
	// completely different routines by sides
	if (startNearFlags) {
		// start at edge of starting tile closer to the flag
		// drive forward then turn to shoot toward high flag
		driveStraight(80, 12);
		rotateAngle(90);
		shoot(3, 30);
		// pick up cap
		rotateAngle(-45);
		driveStraight(80, 20);
		// TODO: lift to pick up the cap
		// drive to pole
		driveStraight(-80, -20);
		rotateAngle(-135);
		driveStraight(80, 24);
		rotateAngle(-90);
		driveStraight(80, 24);
		// TODO: lift the lift
		flipClaw();
		} else {

	}
	angleMultiplier = 1;
}

task usercontrol() {
	startAllTasks();
	while (true) {
		if (vexRT[Btn8D]) {
			driveStraight(80, 24);
		}
		if (vexRT[Btn8R]) {
			rotateAngle(360);
		}
		if (vexRT[Btn8L]) {
			flipClaw();
		}
		doClaw();
		doDrive();
		doArms();
		doConveyor();
		doFlywheel();
	}
}
