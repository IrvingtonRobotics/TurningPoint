#pragma config(Motor,  port1,           driveLeftFront, tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           liftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           liftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           clawFlip,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           conveyor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           flywheelLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           flywheelRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          driveRightFront, tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int deDead(int speed) {
	// deal with dead zone
	if (abs(speed) < 10) {
		return 0;
	}
	return speed;
}

// ---- MOVE: wrappers around atomic movement functions

void moveDrive(int leftPow, int rightPow) {
	// Move the left side of the robot
	motor[driveLeftFront] = leftPow;
	motor[driveLeftBack] = leftPow;
	// Move the right side of the robot
	motor[driveRightFront] = rightPow;
	motor[driveRightBack] = rightPow;
}

void moveArms(int dir) {
	// move both arms in unison
	motor[liftTop] = dir;
	motor[liftBottom] = dir;
}

void moveConveyor(int speed) {
	// move conveyor
	motor[conveyor] = speed;
}

void moveFlywheel(int speed) {
	motor[flywheelLeft] = speed;
	motor[flywheelRight] = speed;
}

void moveClaw(int speed) {
	motor[clawFlip] = speed;
}

// ---- DO: observe input and act upon it

// drive

void doDrive() {
	// one-joystick drive on left joystick (ch 3 and 4)
	int y = deDead(vexRT[Ch3]);
	int x = deDead(vexRT[Ch4]);
	int leftSpeed = x + y;
	int rightSpeed = x - y;
	moveDrive(leftSpeed, rightSpeed);
}

// conveyor

void doConveyor() {
	// buttons 6U and 6D move conveyor up and down
	if (vexRT[Btn6U]) {
		moveConveyor(127);
	} else if (vexRT[Btn6D]) {
		moveConveyor(-127);
	} else {
		moveConveyor(0);
	}
}

// flywheel

void doFlywheel() {
	// button 5D moves flywheel
	if (vexRT[Btn5D]) {
		moveFlywheel(127);
	} else {
		moveFlywheel(0);
	}
}

// arm

void doArms() {
	// Right joystick (ch2) controls arms
	int speed = deDead(vexRT[Ch2]);
	moveArms(speed);
}

// claw

bool clawFlipped = true;
int clawDir = 0;

void flipClaw() {
	clawDir = clawDir + (clawFlipped ? 50 : -50);
	if (abs(clawDir) == 50) {
		clawFlipped = !clawFlipped;
	}
	moveClaw(clawDir);
}

void doClaw() {
	if (vexRT[Btn5U]) {
		flipClaw();
	}
}

// ---- MAIN

task main() {
	while (true) {
		doDrive();
		doArms();
		doClaw();
		doConveyor();
		doFlywheel();
	}
}
