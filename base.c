#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           flywheelLeft,  tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           clawFlip,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveLeftFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveRightFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           conveyor,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          flywheelRight, tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

// main controller
#define leftDriveJoystick vexRT[Ch3]
#define rightDriveJoystick vexRT[Ch4]
#define clawButton vexRT[Btn7U]
#define armJoystick vexRT[Ch2]
// partner (add Xmtr2 to end of name for partner joystick)
#define conveyorUpButton vexRT[Btn6UXmtr2]
#define conveyorDownButton vexRT[Btn6DXmtr2]
#define flywheelButton vexRT[Btn8UXmtr2]

// configs
#define clawPosA 1218
#define clawPosB 4000

// ---- HELPERS

int bound(int in, int min, int max) {
	if (min > max) {
		int temp = min;
		min = max;
		max = temp;
	}
	if (in < min) {
		return min;
	} else if (in > max) {
		return max;
	} else {
		return in;
	}
}

int bound(int in, int absMax) {
	return bound(in, absMax, -absMax);
}

int deDead(int in, int threshold) {
	// deal with dead zone
	if (abs(in) < threshold) {
		return 0;
	}
	return in;
}

int deDead(int in) {
	return deDead(in, 15);
}

// ---- MOVE: wrappers around atomic movement functions

void moveDrive(int leftPow, int rightPow) {
	/* Positive: move forward;
	 * Negative: move backward
	 **/
	// Move the left side of the robot
	motor[driveLeftFront] = leftPow;
	motor[driveLeftBack] = leftPow;
	// Move the right side of the robot
	motor[driveRightFront] = rightPow;
	motor[driveRightBack] = rightPow;
}

void moveArms(int dir) {
	// move both arms in unison
	motor[liftTop] = dir;
	motor[liftBottom] = dir;
}

void moveConveyor(int speed) {
	// move conveyor
	motor[conveyor] = speed;
}

void moveFlywheel(int speed) {
	motor[flywheelLeft] = speed;
	motor[flywheelRight] = speed;
}

void moveClaw(int speed) {
	motor[clawFlip] = speed;
}

int clawPosition() {
	return SensorValue[clawPot];
}

// ---- MOVE: advanced movement (autom helpers)

// drive

void rotateInPlace(int speed) {
	/* positive speed: turn right
   * negative speed: turn left
	 */
  moveDrive(speed, -speed);
}

void driveStraight(int speed) {
	moveDrive(speed, speed);
}

void stopDriving() {
	moveDrive(0, 0);
}

void waitMS(int millis) {
	wait1Msec(millis);
}

void wait(int seconds) {
	wait1Msec(seconds * 1000);
}

void driveDistance(int distance) {
	// calibrate so distance is in inches (1/24 of tile)
	driveStraight(sgn(distance) * 60);
	// TOCALIBRATE
	waitMS(abs(distance) * 10);
	stopDriving();
}


int angleMultiplier = 1;
void rotateAngle(int angle) {
  // calibrate so angle is in degrees
	// positive --> clockwise
	// TOCALIBRATE
	rotateInPlace(sgn(angle)* 60);
	waitMS(abs(angle) * 10);
	stopDriving();
}

void shoot(int flag, int distanceFromBase) {
	// 3 for top flag, 2 for middle flag
	int dx = distanceFromBase;
	int dy;
	if (flag == 3) {
		dy = 46;
	} else if (flag == 2) {
		dy = 32;
	}
	// TODO: now do some physics and speed curve to determine motor control
}

int clawTarget = clawPosA;

void flipClaw() {
	int pos = clawPosition();
	if (abs(pos - clawPosA) < abs(pos - clawPosB)) {
		clawTarget = clawPosB;
	} else {
		clawTarget = clawPosA;
	}
}

// ---- DO: observe input and act upon it

// drive

void doDrive() {
	// two joysticks
	int leftSpeed = deDead(leftDriveJoystick);
	int rightSpeed = deDead(rightDriveJoystick);
	moveDrive(leftSpeed, rightSpeed);
}

// conveyor

void doConveyor() {
	// buttons 6U and 6D move conveyor up and down
	if (conveyorUpButton) {
		moveConveyor(127);
	} else if (conveyorDownButton) {
		moveConveyor(-127);
	} else {
		moveConveyor(0);
	}
}

// flywheel

void doFlywheel() {
	// button 8U runs flywheel
	if (flywheelButton) {
		moveFlywheel(127);
	} else {
		moveFlywheel(0);
	}
}

// arm

void doArms() {
	// Right joystick (ch2) controls arms
	int speed = deDead(armJoystick);
	moveArms(speed);
}

// claw

bool lastClawButtonValue = false;
bool clawFlipped = true;
int clawDir = 0;

void doClaw() {
	/* Button 7U to flip the claw 180 deg
	 * Buttons 5U and 5D move claw back and forth
   */
	// for flipping 180
	bool currentClawButtonValue = clawButton ? true : false;
	if (currentClawButtonValue && !lastClawButtonValue) {
		flipClaw();
	}
	lastClawButtonValue = currentClawButtonValue;
}

// ---- MAIN CONTROL

task clawController() {
	while(true) {
		// TOCALIBRATE
		int error = clawTarget - clawPosition();
		// adjust multiplier as kP (proportionality coefficient)
		int motorPower = error / 7;
		motorPower = bound(motorPower, 127);
		motorPower = deDead(motorPower);
		moveClaw(motorPower);
		wait1Msec(1);
	}
}

void pre_auton() {
	// stop tasks while changing from autonomous to usercontrol
  bStopTasksBetweenModes = true;
}

task autonomous() {
	startTask(clawController);
	while (true) {
		clawTarget = clawPosA;
		wait(3);
		clawTarget = clawPosB;
		wait(3);
	}
	// 85 is p much max speed since speed is nonlinear, 60 is reasonable speed
	bool isRed = false;
	// practice as if blue, then negative of drive angles for red
	angleMultiplier = isRed ? -1 : 1;
	// false --> starting position closer to flags
	// true --> starting position closer to posts
	bool startNearFlags = true;
	// completely different routines by sides
	if (startNearFlags) {
		// start at edge of starting tile closer to the flag
		// drive forward then turn to shoot toward high flag
		driveDistance(12);
		rotateAngle(90);
		shoot(3, 30);
		// pick up cap
		rotateAngle(-45);
		driveDistance(20);
		// TODO: lift to pick up the cap
		// drive to pole
		driveDistance(-20);
		rotateAngle(-135);
		driveDistance(24);
		rotateAngle(-90);
		driveDistance(24);
		// TODO: lift the lift
		flipClaw();
	} else {

	}
	angleMultiplier = 1;
}

task usercontrol() {
	startTask(clawController);
  while (true) {
		// testing out durations
  	// change the time inside waitMS directly after TOCALIBRATE comments
  	// haha we won't need this once we get those encoders attached
		if (vexRT[Btn8D]) {
			driveDistance(24);
		}
		if (vexRT[Btn8R]) {
			rotateAngle(360);
		}
		if (vexRT[Btn8L]) {
			flipClaw();
		}
		doClaw();
    doDrive();
		doArms();
		doConveyor();
		doFlywheel();
  }
}
